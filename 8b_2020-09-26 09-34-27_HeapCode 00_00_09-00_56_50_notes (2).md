# Lecture Notes: 8B 2020-09-26 09-34-27 Heapcode 00 00 09-00 56 50

### Introduction to Heaps and their Properties

This section introduces **heaps**, a specialized tree-based data structure with important properties that make them efficient for certain operations.  We will focus on the characteristics of heaps and their array-based implementation.

**Definition:** A **heap** is a **binary tree** that satisfies two crucial properties:

*   **Shape Requirement:** The heap is an *essentially complete binary tree*. This means all levels are completely filled, except possibly the last level, which is filled from left to right.  No internal node can have only one child.

*   **Parental Dominance Requirement (Heap Property):**  For a **max-heap**, the key (value) of each node is *greater than or equal to* the keys of its children. For a **min-heap**, the key of each node is *less than or equal to* the keys of its children.  This property ensures a specific ordering within the tree.


**Example:**

Consider the following binary trees:

```
      92
    /   \
   57    86
  / \   / \
 48 37 33 25
/ \
12 25

      92
    /   \
   86    57
  / \   / \
 33 25 48 37
/ \
12 25
```

Only the first tree is a valid **max-heap**. The second tree violates the heap property (e.g., 57 is a parent of 48 and 37, but 57 < 86).  Note that both trees are essentially complete binary trees, fulfilling the shape requirement.


**Array Representation:** Heaps are efficiently implemented using arrays.  The elements are stored level-by-level, from left to right.  For example, the first tree above can be represented as:

`[92, 57, 86, 48, 37, 33, 25, 12, 25]`

*   The root element (92) is at index 0 (or 1, depending on the implementation).
*   The children of a node at index `i` are at indices `2i + 1` and `2i + 2`.
*   The parent of a node at index `i` is at index `floor((i - 1) / 2)`.

**Properties of Heaps:**

*   The **root** of a **max-heap** always contains the **largest element**, and the root of a **min-heap** always contains the **smallest element**.
*   A subtree of a heap is also a heap.
*   The height of a heap with *n* nodes is  ⌊log₂n⌋.  This logarithmic height contributes to the efficiency of heap operations.
*   Heap construction (heapify) can be done efficiently in O(n) time using a top-down approach, as demonstrated in the lecture transcript.  This approach iteratively inserts elements into the heap, ensuring the heap property is maintained after each insertion.


The lecture transcript demonstrates a **top-down heap construction** algorithm for creating a descending (max) heap from an unsorted array.  The algorithm iteratively considers each element, starting from the second element, and "heapifies" it by comparing it with its parent and swapping if necessary to maintain the heap property.  This process continues until the element finds its correct position in the heap.  The code example in the transcript illustrates this process.


### Heap Representation using Arrays

A **heap**, as defined previously, is a specialized tree-based data structure that satisfies two key properties:  the **shape requirement** (a complete binary tree, meaning all levels are full except possibly the last, which is filled from left to right) and the **parental dominance requirement** (the value of each node is greater than or equal to the values of its children in a **max-heap**, or less than or equal to in a **min-heap**).  While heaps can be represented using trees, a more efficient and common implementation utilizes arrays.

**Array Representation:**

The array representation leverages the inherent structure of a complete binary tree.  By storing the heap's elements in an array, we can directly calculate the indices of a node's parent and children without needing explicit pointers.  This significantly reduces memory overhead and improves performance.

* **Index Mapping:**  Let's assume the array is indexed from 1 (some implementations use 0, but 1 simplifies the formulas).  Given a node at index `i`:
    * Its **parent** is located at index `⌊i/2⌋`.
    * Its **left child** is located at index `2i`.
    * Its **right child** is located at index `2i + 1`.

* **Example:** Consider a max-heap represented in an array: `H = [-, 92, 86, 57, 37, 33, 48, 12, 25]` (Note the `-` at index 0, often used as a placeholder).

    * The root (92) is at index 1.
    * The left child of the root (86) is at index 2.
    * The right child of the root (57) is at index 3.
    * The left child of the node at index 2 (37) is at index 4.
    * And so on...

**Heap Operations using Array Representation:**

The efficiency of heap operations (**insertion**, **deletion**, **heapify**) stems directly from this array representation.  The index calculations allow for quick navigation through the heap structure without the overhead of traversing tree pointers.  The lecture transcript describes the process of heapsort, which involves building a heap from an unsorted array and then repeatedly extracting the maximum element (root) to build a sorted array.  This process relies heavily on the efficient array-based representation.

**Heapify:** The transcript details the *heapify* operation, which ensures that the parental dominance requirement is maintained after an element is inserted or deleted. This involves repeatedly comparing a node with its children and swapping them if the parental dominance is violated.  The process continues recursively until the heap property is restored.

**Heapsort:** The transcript demonstrates the *heapsort* algorithm, which utilizes the array representation.  It involves:

1. **Building the heap:** Transforming the input array into a max-heap.
2. **Repeatedly extracting the maximum:**  The largest element (root) is swapped with the last element, the heap size is reduced, and the heap is re-heapified.  This process is repeated until the heap is empty, resulting in a sorted array.


The array representation provides a compact and efficient way to implement heaps, making them suitable for various applications, including priority queues and heapsort.  The lecture transcript illustrates the practical application of this representation in the context of heapsort, highlighting the importance of index calculations for efficient heap manipulation.


### Heap Construction: Bottom-Up Approach (Detailed Explanation)

This section details the bottom-up approach to **heap construction**, a more efficient method than building a heap by inserting elements one at a time.  The bottom-up approach leverages the fact that a nearly complete binary tree can be represented efficiently as an array.  The algorithm starts by treating the input array as a binary tree and then "heapifies" it, ensuring the **heap property** (parental dominance) is satisfied at every node.

**Algorithm:**

The bottom-up heap construction algorithm iterates through the array from the last non-leaf node up to the root.  For each node, it performs a **heapify** operation.

* **Heapify Operation:**  This operation ensures that the node satisfies the heap property.  It compares the key of the current node with the keys of its children. If a child has a larger key than the parent, they are swapped. This process is recursively applied to the subtree rooted at the child node until the heap property is satisfied for the entire subtree.

**Detailed Steps:**

1. **Array Representation:** The input array is treated as a complete binary tree. The root is at index 0 (or 1, depending on the implementation), the left child of a node at index `i` is at `2i + 1`, and the right child is at `2i + 2`.

2. **Iteration:** The algorithm iterates through the array from the last non-leaf node to the root. The last non-leaf node is located at index `⌊(n-1)/2⌋`, where `n` is the number of elements in the array.

3. **Heapify:** For each node visited during the iteration, the `heapify` operation is performed. This operation recursively ensures that the subtree rooted at that node satisfies the heap property.

4. **Termination:** Once the loop completes, the entire array represents a valid **max-heap** (or **min-heap**, depending on the comparison used in `heapify`).

**Example:**

Let's consider the array `[12, 37, 25, 33, 1, 86, 92, 57, 48]`.  We will build a max-heap.

1. **Identify the last non-leaf node:**  `⌊(9-1)/2⌋ = 4`.  The node at index 4 (value 1) is the last non-leaf node.

2. **Iteration and Heapify:** We start heapifying from index 4 and move upwards.

   * **Index 4 (value 1):**  Heapify is called.  1 is compared with its children (if any).  No children exist, so no changes are made.

   * **Index 3 (value 33):** Heapify is called. 33 is compared with its children (86 and 57). 86 > 33, so they are swapped.  The new array is `[12, 37, 25, 86, 1, 33, 92, 57, 48]`.  Heapify is recursively called on the subtree rooted at index 7 (57).  No further swaps are needed.

   * **Index 2 (value 25):** Heapify is called. 25 is compared with its children (86 and 33). 86 > 25, so they are swapped. The new array is `[12, 37, 86, 33, 1, 25, 92, 57, 48]`. Heapify is recursively called on the subtree rooted at index 7 (57). No further swaps are needed.

   * **Index 1 (value 37):** Heapify is called. 37 is compared with its children (86 and 33). 86 > 37, so they are swapped. The new array is `[12, 86, 37, 33, 1, 25, 92, 57, 48]`. Heapify is recursively called on the subtree rooted at index 3 (33). No further swaps are needed.

   * **Index 0 (value 12):** Heapify is called. 12 is compared with its children (86 and 37). 86 > 12, so they are swapped. The new array is `[86, 37, 37, 33, 1, 25, 92, 57, 48]`.  This process continues until the heap property is satisfied for the entire tree.


3. **Result:** After completing the iterations, the array represents a max-heap.  The largest element (92) is at the root.

**Time Complexity:** The time complexity of the bottom-up heap construction is O(n), where n is the number of elements. This is significantly more efficient than the O(n log n) complexity of inserting elements one by one.


**Space Complexity:** The space complexity is O(1) as it operates in-place on the input array.


### Bottom-Up Heap Construction: Step-by-Step Example

This section details the bottom-up approach to **heap construction**, illustrating the process with a step-by-step example.  The goal is to transform an unsorted array into a **heap**, a specialized tree-based data structure where the value of each node is greater than or equal to the values of its children (in a **max-heap**, as considered here).  The bottom-up approach leverages the fact that a nearly complete binary tree can be efficiently represented as an array.

**Algorithm Overview:**

The bottom-up heap construction algorithm iterates through the array from the last non-leaf node up to the root. For each node, it performs a **heapify** operation.  Heapify ensures that the subtree rooted at that node satisfies the heap property.  This is done by comparing the node with its children and swapping it with the larger child if necessary, recursively applying the process until the heap property is restored within the subtree.

**Step-by-Step Example:**

Let's consider the following unsorted array:  `[25, 57, 48, 37, 12, 92, 86, 33]`

1. **Array Representation:** We represent the array as a nearly complete binary tree.  Note that the indices are 0-based, but for heap operations, we often conceptually start from index 1.

   ```
           25
      57       48
   37   12  92   86
  33
   ```

2. **Identifying Non-Leaf Nodes:** We start heapifying from the last non-leaf node.  In a complete binary tree, the last non-leaf node is located at index `⌊(n-1)/2⌋`, where 'n' is the number of elements. In our example, `⌊(8-1)/2⌋ = 3`.  Therefore, we begin with the node containing 37.

3. **Heapify Operation (Iteration 1):**

   * We start with the node at index 3 (value 37).
   * Its children are at indices 7 (value 33) and 8 (value - no child).
   * Since 37 > 33, no swap is needed.  The subtree rooted at 37 is already a heap.

4. **Heapify Operation (Iteration 2):**

   * Next, we consider the node at index 2 (value 48).
   * Its children are at indices 5 (value 92) and 6 (value 86).
   * 48 < 92, so we swap 48 and 92.
   * The array becomes: `[25, 57, 92, 37, 12, 48, 86, 33]`
   * The tree becomes:

     ```
             25
        57       92
     37   12  48   86
    33
     ```

   * Now, we check if the subtree rooted at 92 needs further heapifying.  Since 92 is the largest element in its subtree, no further action is required.

5. **Heapify Operation (Iteration 3):**

   * We move to the node at index 1 (value 57).
   * Its children are at indices 3 (value 37) and 4 (value 12).
   * 57 > 37 and 57 > 12, so no swap is needed.

6. **Heapify Operation (Iteration 4):**

   * Finally, we consider the root node at index 0 (value 25).
   * Its children are at indices 1 (value 57) and 2 (value 92).
   * 25 < 57 and 25 < 92, so we swap 25 with 92.
   * The array becomes: `[92, 57, 25, 37, 12, 48, 86, 33]`
   * The tree becomes:

     ```
             92
        57       25
     37   12  48   86
    33
     ```

   * We continue heapifying down from 92.  This involves further swaps until the heap property is satisfied for the entire tree.

7. **Final Heap:** After completing the heapify operations for all non-leaf nodes, the array represents a **max-heap**.  The largest element (92) is at the root.

**Note:** The transcript provides a less structured and slightly confusing explanation of the process.  This detailed explanation clarifies the steps involved in the bottom-up heap construction algorithm.  The final heap structure may vary slightly depending on the choices made during the heapify operations if multiple children have the same value.  The core principle remains the same: ensure the heap property is maintained at each step.


### Illustrative Example of Bottom-Up Heap Construction (using 25, 57, 48, 37, 12, 92, 86, 33)

This section details the bottom-up construction of a **max-heap** using the elements {25, 57, 48, 37, 12, 92, 86, 33}.  A max-heap is a **complete binary tree** where the value of each node is greater than or equal to the values of its children.  The bottom-up approach builds the heap by starting from the leaves and working upwards.

**Step 1: Initial Array Representation**

We begin by representing the elements in an array.  Note that a complete binary tree can be efficiently represented using an array.  The root is at index 0 (or 1, depending on the implementation), and the children of a node at index *i* are at indices 2*i* + 1 and 2*i* + 2.

```
Array: [25, 57, 48, 37, 12, 92, 86, 33]
```

This array does *not* yet represent a heap.

**Step 2: Heapify from the Bottom**

The bottom-up construction involves iterating through the array from the last non-leaf node upwards.  The last non-leaf node is located at index ⌊(n-1)/2⌋, where *n* is the number of elements. In our case, n = 8, so the last non-leaf node is at index ⌊(8-1)/2⌋ = 3.

We will use a **heapify** function to ensure that the subtree rooted at each node satisfies the max-heap property.  The heapify function recursively compares a node with its children and swaps it with the larger child if necessary, then recursively calls itself on the affected subtree.

* **Iteration 1 (i = 3):**  We start with the node at index 3 (value 37). Its children are at indices 7 (33) and 6 (86). 86 > 37, so we swap 37 and 86.

```
Array: [25, 57, 48, 86, 12, 92, 37, 33]
```

* **Iteration 2 (i = 2):**  Node at index 2 (value 48). Children are at indices 5 (92) and 4 (12). 92 > 48, so we swap 48 and 92.

```
Array: [25, 57, 92, 86, 12, 48, 37, 33]
```

* **Iteration 3 (i = 1):** Node at index 1 (value 57). Children are at indices 3 (86) and 2 (92). 92 > 57, so we swap 57 and 92.

```
Array: [25, 92, 57, 86, 12, 48, 37, 33]
```

* **Iteration 4 (i = 0):** Node at index 0 (value 25). Children are at indices 1 (92) and 2 (57). 92 > 25, so we swap 25 and 92.

```
Array: [92, 57, 25, 86, 12, 48, 37, 33]
```

Now, we continue the heapify process down the tree, ensuring that the max-heap property is maintained at each level.  The exact steps would involve further comparisons and swaps, but the process is similar to the iterations above.  The final result will be a max-heap.

**Step 3: Resulting Max-Heap**

After completing the heapify process for all non-leaf nodes, the array will represent a max-heap.  The exact final arrangement may vary slightly depending on the implementation of the heapify function, but the largest element (92) will always be at the root.  The resulting array will be a valid max-heap representation.  The exact final array representation will depend on the specific implementation of the heapify algorithm, but the key is that the max-heap property will be satisfied throughout the tree.  A visual representation of the heap would show the largest element at the root, with smaller elements arranged such that the parent is always greater than or equal to its children.


### Detailed Algorithm and Code Explanation (implied, but not explicitly stated in provided text)

This section details the algorithm and code implementation for **heap sort**, a sorting algorithm that leverages the properties of a **heap data structure**.  The lecture transcript describes a **bottom-up heap construction** followed by a **heap sort** procedure.  Let's break down both:

**I. Heap Construction (Heapify):**

The lecture demonstrates building a heap from an unsorted array.  The algorithm uses a **bottom-up** approach, starting from the last non-leaf node and working upwards.  Each node is checked to ensure it satisfies the **heap property** (parent node value ≥ child node values). If not, the node is swapped with its largest child, and the process recursively continues down the tree until the heap property is restored for that subtree.

* **Algorithm:**

  1. **Initialization:** Start at the last non-leaf node (index ⌊(n-1)/2⌋, where n is the number of elements).
  2. **Iteration:** Iterate through the nodes from ⌊(n-1)/2⌋ down to 0.
  3. **Heapify:** For each node at index `i`:
     * Find the largest child (left child at 2i+1 and right child at 2i+2).
     * If the largest child is greater than the parent (`i`), swap them.
     * Recursively call `heapify` on the subtree rooted at the largest child's index until the heap property is satisfied for that subtree.


* **Example:**

Let's consider the array [25, 57, 48, 37, 12, 92, 86, 33].  The heap construction would proceed as follows:

1. Start at index ⌊(8-1)/2⌋ = 3 (element 37).
2. `heapify(3)`: 37 < 86, swap.  The subtree rooted at 6 is checked recursively.
3. Continue this process for indices 2, 1, and 0.  The final heap would be [92, 86, 57, 37, 12, 48, 25, 33].


**II. Heap Sort:**

Once the heap is constructed, the heap sort algorithm extracts the largest element (root) repeatedly, placing it at the end of the array.  The remaining elements are then re-heapified to maintain the heap property.

* **Algorithm:**

  1. **Heap Construction:** Build a max-heap from the input array (as described above).
  2. **Iteration:** Repeat steps 3-5 until only one element remains in the heap.
  3. **Extract Max:** Swap the root (largest element) with the last element in the heap.
  4. **Reduce Heap Size:** Decrement the heap size (effectively removing the largest element from the heap).
  5. **Heapify:** Re-heapify the remaining elements (call `heapify(0)`).


* **Example (Continuing from above):**

1. The heap is [92, 86, 57, 37, 12, 48, 25, 33].
2. Swap 92 and 33: [33, 86, 57, 37, 12, 48, 25, 92].  Heap size is now 7.
3. `heapify(0)` re-arranges the first 7 elements to maintain the heap property.
4. Repeat steps 2-3 until the array is sorted: [12, 25, 33, 37, 48, 57, 86, 92].


**III. Code (Partial, based on lecture transcript):**

The lecture transcript provides a high-level description of the code. A complete, optimized implementation would require more detail and error handling. However, based on the transcript, a skeletal implementation in C++ might look like this:

```cpp
#include <iostream>
#include <vector>

void heapify(std::vector<int>& a, int i, int n) {
  int largest = i;
  int l = 2 * i + 1;
  int r = 2 * i + 2;

  if (l < n && a[l] > a[largest])
    largest = l;
  if (r < n && a[r] > a[largest])
    largest = r;

  if (largest != i) {
    std::swap(a[i], a[largest]);
    heapify(a, largest, n);
  }
}

void heapSort(std::vector<int>& a) {
  int n = a.size();

  // Build heap (bottom-up)
  for (int i = n / 2 - 1; i >= 0; i--)
    heapify(a, i, n);

  // Extract max and re-heapify
  for (int i = n - 1; i > 0; i--) {
    std::swap(a[0], a[i]);
    heapify(a, 0, i);
  }
}

int main() {
  std::vector<int> arr = {25, 57, 48, 37, 12, 92, 86, 33};
  heapSort(arr);
  for (int x : arr)
    std::cout << x << " ";
  std::cout << std::endl;
  return 0;
}
```

This code provides a basic framework.  A production-ready implementation would include more robust error handling and potentially optimizations.  The lecture's description of child index calculation and loop conditions is reflected in the `heapify` function.  The `heapSort` function orchestrates the heap construction and element extraction phases.  Remember that this is a simplified representation based on the limited information provided in the lecture transcript.


### Comparison of Parent and Child Nodes during Heap Construction

This section details the crucial comparisons made between parent and child nodes during the **heap construction** process, specifically focusing on the **bottom-up heapify** algorithm.  The algorithm iteratively compares and swaps elements to satisfy the **heap property**:  a parent node's key is always greater than or equal to the keys of its children.  This ensures the largest element resides at the root.

The transcript describes a step-by-step example of heap construction.  The core process involves:

1. **Starting from the last non-leaf node:** The algorithm begins at the lowest level of the heap, working its way upwards.  This is because leaf nodes inherently satisfy the heap property (having no children).

2. **Identifying the parent and children:** For each node, its children are identified (left child at index 2i+1, right child at index 2i+2, where 'i' is the parent's index).

3. **Comparison and potential swap:** The parent node's key is compared with the keys of its children.  If a child's key is greater than the parent's key, a **swap** occurs.  This ensures the larger element "bubbles up" towards the root.

4. **Recursive comparison:** After a swap, the algorithm recursively compares the newly positioned element with *its* children, continuing the "bubble-up" process until the heap property is restored for that subtree.

**Example:**

Let's consider a portion of the transcript's example where the element '12' is displaced.  The current state of the heap (represented as an array) might look like this:

[37, 33, 48, 25, 12]

* **Iteration 1:**  '12' is displaced (potentially from a later stage of the algorithm).  The algorithm starts by comparing '48' (parent) with '25' and '12' (children).  '48' > '25' and '48' > '12', so no swap is needed at this level.

* **Iteration 2:** The algorithm moves to the next parent node, '33'.  It compares '33' with '25' and '12'.  '33' > '12', but '33' < '25' is false.  Therefore, '25' and '33' are swapped, resulting in:

[37, 25, 48, 33, 12]

* **Iteration 3:** Now '33' is compared with its children (only '12' in this case).  '33' > '12', so no swap is needed.  The heap property is restored for this subtree.

The process continues until the entire heap is **heapified**, ensuring that the largest element is at the root and the heap property holds for all subtrees.  The transcript highlights that the choice of which child to swap with (if both are greater than the parent) is determined by selecting the larger of the two children.  This ensures the largest element rises to the top efficiently.  The algorithm's termination condition is when the displaced element reaches a position where it is greater than or equal to its children, or it becomes a leaf node.


### Handling Boundary Conditions during Heap Construction

This section addresses the challenges encountered when constructing a **heap** using the **bottom-up** (or **heapify**) approach, specifically focusing on how to manage boundary conditions during the iterative process.  The core issue lies in correctly handling the **displaced element** (the element moved from its initial position during heapification) and ensuring its proper placement within the partially constructed heap.

The bottom-up heap construction algorithm iterates through the array representing the heap from the last non-leaf node up to the root.  For each node, it performs a **heapify** operation, which ensures that the node satisfies the **heap property** (parent node value ≥ child node values).  However, this process involves moving elements, creating boundary conditions that need careful consideration.

**The Problem:**

During heapification, an element might be displaced from its current position.  The algorithm must then determine the correct position for this displaced element within the already partially ordered heap.  This is particularly challenging near the boundaries of the heap (i.e., the leaves and nodes close to the leaves).  The algorithm must correctly compare the displaced element with its potential children and ensure that the heap property is maintained throughout the process.

**Addressing Boundary Conditions:**

The transcript and the implied algorithm highlight several key aspects of handling these boundary conditions:

* **Iteration Order:** The algorithm iterates from the last non-leaf node (index `n/2 - 1` in a 0-indexed array) upwards towards the root (index 0). This ensures that sub-heaps are already constructed before processing their parent nodes.

* **Displaced Element Handling:** The algorithm identifies the **displaced element** (e.g., `a[i]` in the transcript). This element is temporarily stored while its correct position is determined.

* **Child Selection:**  The algorithm dynamically selects the appropriate child node to compare with the displaced element.  It considers both the left and right children (indices `2p + 1` and `2p + 2` respectively, where `p` is the parent index). The child with the larger value is selected for comparison.  The algorithm explicitly checks for boundary conditions to ensure that it doesn't attempt to access indices outside the valid range of the array.

* **Recursive Heapify (Implicit):** While the transcript doesn't explicitly use recursion, the process of repeatedly comparing the displaced element with its children and swapping them until the heap property is satisfied implicitly performs a recursive-like operation.  This ensures that the displaced element "bubbles down" to its correct position in the heap.

* **Termination Condition:** The iterative process terminates when the displaced element is in its correct position (i.e., it is no longer greater than either of its children) or when it reaches a leaf node.

**Example:**

Consider the array [12, 32, 54, 76, 1].  The heap construction would proceed as follows:

1. **Iteration i = 2 (last non-leaf node):**  `a[2] = 54`.  54 is compared with its children (76 and 1). 76 > 54, so no swap is needed.

2. **Iteration i = 1:** `a[1] = 32`. 32 is compared with its children (54 and 1). 54 > 32, so no swap is needed.

3. **Iteration i = 0 (root):** `a[0] = 12`. 12 is compared with its children (32 and 54). 32 > 12 and 54 > 12.  12 is swapped with 54 (the larger child).  The process continues recursively until 12 finds its correct position.

The transcript's example demonstrates the careful handling of boundary conditions, especially when the displaced element is near the leaves. The algorithm correctly determines the appropriate child to compare against and handles cases where a child might be missing (at the edges of the heap).  The condition `c >= i - 1` effectively prevents out-of-bounds access.

In summary, handling boundary conditions during bottom-up heap construction requires careful attention to the iteration order, displaced element management, child selection, and termination conditions.  The algorithm must dynamically adapt to the structure of the partially constructed heap to ensure the correct placement of the displaced element and maintain the heap property.
